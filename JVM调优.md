- [JVM 调优](#jvm-调优)
  - [Java 执行流程](#java-执行流程)
  - [JDK \& JRE \& JVM](#jdk--jre--jvm)
  - [Java 字节码文件结构](#java-字节码文件结构)
  - [类加载](#类加载)
    - [装载](#装载)
    - [链接](#链接)
    - [初始化](#初始化)
  - [类加载器](#类加载器)
  - [双亲委派模型](#双亲委派模型)
  - [JVM 内存模型](#jvm-内存模型)
  - [线程独享区](#线程独享区)
    - [程序计数器](#程序计数器)
    - [本地方法栈](#本地方法栈)
    - [虚拟机栈](#虚拟机栈)
    - [栈帧](#栈帧)
    - [栈帧的结构](#栈帧的结构)
    - [虚拟机栈溢出以及调优](#虚拟机栈溢出以及调优)
  - [线程共享区](#线程共享区)
    - [方法区](#方法区)
  - [JVM 执行引擎](#jvm-执行引擎)
    - [解释器与即时编译器](#解释器与即时编译器)
  - [堆内存模型](#堆内存模型)
    - [Java 对象内存布局](#java-对象内存布局)
    - [JVM 内存溢出和垃圾回收机制](#jvm-内存溢出和垃圾回收机制)
    - [Java 堆内存的划分](#java-堆内存的划分)

--------------------------


# JVM 调优  
  

## Java 执行流程  



## JDK & JRE & JVM



## Java 字节码文件结构



## 类加载

### 装载

### 链接

### 初始化

## 类加载器

## 双亲委派模型

## JVM 内存模型

## 线程独享区

### 程序计数器

### 本地方法栈

### 虚拟机栈

### 栈帧

### 栈帧的结构

### 虚拟机栈溢出以及调优

- 1. 栈的溢出
  栈的空间是有限的，由于栈帧调用的深度太深，就会出现虚拟机栈溢出异常（**java.lang.StackOverFlowError**--**-SOF异常**）由于一个栈帧很小，手动方法一个个添加栈帧达到溢出往往不太可能，所以出现SOF异常往往是由于递归嵌套导致的
- 2. 解决方法
  可以通过修改虚拟机栈的内存大小来预防虚拟机栈的溢出:  ```-Xss 虚拟机栈内存大小```虚拟机栈不可过大也不可过小，太小：虚拟机栈容易溢出，太大：会使每个线程所占据的内存过大，影响线程数量。

## 线程共享区

### 方法区

- 1. 在java8之后，我们把方法区称之为**元空间**（MetaSpace）,方法区在逻辑上属于堆的一部分（方法区和堆内存他们的内存是混一起的，他们是一块内存），但是在一些具体机制和堆有所区别，如：一些JVM的方法区是可以不进行垃圾回收的，关闭JVM时才会释放方法堆内存。所以方法区还有一个别名叫**非堆**，目的是和堆分开。  
- 2. 方法区会储存[**类信息**](#jvm-调优)，[**静态变量**](#jvm-调优)，[**常量**](#jvm-调优)，[**本地机器指令**](#解释器与即时编译器)。
- 3. 在方法区中类信息是最占空间的，如果大量加载class文件，也会造成方法区内存泄漏，比如tomcat运行20~30个项目。

## JVM 执行引擎

- 1. 什么是JVM执行引擎  
    执行引擎是java虚拟机核心组成部分之一。JVM将字节码装载到内存，但字节码不能直接运行在操作系统之上。为了执行内存中的**字节码指令**，执行引擎（Execution Engine）就要将字节码指令解释/编译为对应平台的本地**机器指令**。  
- 2. 执行引擎的翻译过程有两种：  
    通过**解释器**将字节码文件**转换**为机器指令执行；  
    使用**即时编译器**（**JIT**）将字节码文件**编译**成机器指令执行
- 3. 当前的主流JVM
    采用解释器与即时编译器并存的架构。在Java虚拟机运行时，**解释器**和**即时编译器**相互协助，取长补短。

### 解释器与即时编译器

- 1. **解释器**每次解释都会将字节码文件解释为机器指令。整体效率较低，但当程序启动后，解释器可以马上发挥作用，省去编译的时间，**立即执行**。
- 2. **即时编译器**则会将字节码文件编译为机器指令，存在方法区中，编译完成后直接执行本地机器指令即可。编译器把代码编译成本地代码需要一定的执行时间，但编译为本地代码后执行效率高。
- 3. **合作**：当Java虚拟机启动时，**解释器**首先发挥作用，不必等待即时编译器全部编译完成后再执行。随着时间的推移，**编译器**把更多的代码编译成本地代码，此时运行本地机器指令，获得更高的执行效率。

## 堆内存模型

  - JVM将对象存放在堆内存中，堆内存所需要的空间是比较大的。我们对于JVM的调优也主要是针对堆内存的调优，比如分配的空间，那么我们如何能确定堆内存需要分配多少空间呢？我们需要大概计算每个对象所占的空间大小。

### Java 对象内存布局

![the picture for Java object](/img/image.png)

 Java对象在内存中主要有以下几个部分：
- 1. 对象头  
  **MarkWord**：一系列标记位（哈希码：对象的一些特征，分代年龄：对象经历过多少次垃圾回收，锁状态标记等），在64位系统中占8字节。  
  **ClassPoint**：对象的**类信息**的内存地址，在64位系统中占8字节。
  **Length**：数组对象特有，表示数组长度，占4字节。
- 2. **实例数据**：包含了对象的所有成员变量，大小由变量类型决定。
- 3. **对齐填充**：将对象的大小填充为8字节的整数倍。
  
### JVM 内存溢出和垃圾回收机制

- 1. 为什么要进行垃圾回收：如果对象只创建不回收，会造成堆内存溢出（**OOM**）异常。
- 2. 为什么要进行堆内存分区：  
  提高搜索垃圾的效率；  
  垃圾回收后可以更好的利用内存空间，存放大对象；  
  尽可能的减少**GC**（垃圾回收）次数；  
  （如果堆内存一整块不分区，会导致垃圾搜索从头开始，降低效率，内存碎片化严重，大内存对象无法进入从而导致频繁垃圾回收） 

### Java 堆内存的划分

![the picture for Java Memory](/img/image2.png)

- 1. **老年代**：对象会优先分配到新生代内存中，每次GC后没有回收的对象年龄+1，当年龄到**15**还没有回收，对象会存放到老年代内存中；如果对象较大，超过新生代内存的一半，对象也会存放到老年代区域。
- 2. **新生代**：为了减少**young区**垃圾回收后产生的空间碎片，新生代又分为**Eden区**和两个**Survivor区**，且始终有一个**Survivor区**保持闲置。对象会先存放在**Eden区**中，当**Eden区**空间满了之后会进行**young区**的垃圾回收，之后将**young区**所有的存活对象复制到闲置的**Suvivor区**中，并清空**Eden区**和正在使用的**Suvivor区**。

